---
title: 链表
description: 
date: 2025-11-09T00:12:48+08:00
draft: false
featureimage: https://free.picui.cn/free/2025/11/09/691057a44c3fa.png
categories:
    - leetcode
tags:
    - 笔试
    - 算法
---

{{< katex >}}

## 链表翻转

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // 上一个节点默认为null
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr) {
            // 记录下一个节点
            ListNode* next = curr->next;
            // 当前节点的下一个为上一个节点
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};
```

## 循环链表

#### 判断是否是环形链表

Floyd判圈算法【龟兔赛跑算法】，快慢指针

定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。

初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。
否则快指针将到达链表尾部，该链表不为环形链表。

#### 判断环形链表的入口点

![huanxinglianbiao](https://assets.leetcode-cn.com/solution-static/142/142_fig1.png)

快慢指针

fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。

slow 指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为

$$
a+n(b+c)+b=a+(n+1)b+nc
$$

任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有

$$
a+(n+1)b+nc=2(a+b)⟹ a=c+(n−1)(b+c)
$$

有了a=c+(n−1)(b+c)的等量关系，我们会发现：从相遇点到入环点的距离加上 n−1 圈的环长，恰好等于从链表头部到入环点的距离。

因此**当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr指向链表头部, 随后它随slow每次向后移动一个位置。最终，它们会在入环点相遇。**

